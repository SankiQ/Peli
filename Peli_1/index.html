<!DOCTYPE html>
<html>
<head>
    <title>Paratrooper</title>
    <meta charset="UTF-8">
    <style>
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0; 
            background: #000000;
           
        }
        canvas { 
            border: 2px solid #333; 
            background-image: url('https://i.pinimg.com/736x/4a/e6/48/4ae648aaacc1bccfef1f649245adc6a2.jpg');
            background-size: cover;
            background-position: center;
            
        }
    </style>
</head>
<body>
    <canvas id="c" width="800" height="600"></canvas>
    <script>
        const c = document.getElementById('c'), ctx = c.getContext('2d');
        const CFG = {
            lives: 5, diffInc: 2500, fireNormal: 167, fireBurst: 17, burstDur: 3000, burstCool: 8000,
            spawnPlane: 2000, spawnCrate: 4000, crateChance: 0.05, speedBullet: 0.7, speedPlane: 0.24,
            speedPara: 0.06, speedCrate: 0.25, bulletR: 3, paraHP: [1, 3, 6], scoreVals: [100, 300, 600]
        };
        
        class Game {
            constructor() {
                this.reset();
                c.addEventListener('mousemove', e => {
                    const rect = c.getBoundingClientRect();
                    this.cannonAngle = Math.max(-Math.PI, Math.min(0, Math.atan2(e.clientY - rect.top - 560, e.clientX - rect.left - 400)));
                });
                c.addEventListener('mousedown', () => this.mouseDown = true);
                c.addEventListener('mouseup', () => this.mouseDown = false);
                c.addEventListener('click', () => {
                    if (!this.started) { this.started = true; this.audio.resume(); }
                    else if (this.over) this.reset();
                });
                document.addEventListener('keydown', e => {
                    if (e.code === 'Space' && !this.burst && this.burstCool <= 0) {
                        this.burst = true; this.burstTimer = CFG.burstDur; this.fireRate = CFG.fireBurst;
                    }
                });
            }
            
            reset() {
                this.score = 0; this.lives = CFG.lives; this.over = false; this.started = false;
                this.bullets = []; this.planes = []; this.paras = []; this.crates = [];
                this.cannonAngle = -Math.PI/4; this.mouseDown = false; this.fireRate = CFG.fireNormal;
                this.fireTimer = 0; this.planeTimer = 0; this.crateTimer = 0;
                this.burst = false; this.burstTimer = 0; this.burstCool = 0;
                this.diff = 1; this.lastDiff = 0; this.lastTime = 0; this.dt = 0;
                this.fx = { slow: 0, mult: 0, spread: 0, big: 0 };
                this.audio = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            update(t) {
                if (!this.lastTime) this.lastTime = t;
                this.dt = t - this.lastTime; this.lastTime = t;
                if (!this.started || this.over) return;
                
                Object.keys(this.fx).forEach(k => { if (this.fx[k] > 0) this.fx[k] -= this.dt; });
                
                if (this.burst) {
                    this.burstTimer -= this.dt;
                    if (this.burstTimer <= 0) { this.burst = false; this.fireRate = CFG.fireNormal; this.burstCool = CFG.burstCool; }
                }
                if (this.burstCool > 0) this.burstCool -= this.dt;
                
                if (this.mouseDown) {
                    this.fireTimer += this.dt;
                    if (this.fireTimer >= this.fireRate) {
                        this.fire(); this.fireTimer = 0;
                    }
                }
                
                this.planeTimer += this.dt;
                if (this.planeTimer > CFG.spawnPlane) { this.planes.push(this.mkPlane()); this.planeTimer = 0; }
                
                this.crateTimer += this.dt;
                if (this.crateTimer > CFG.spawnCrate && Math.random() < CFG.crateChance) {
                    this.crates.push({ x: 50 + Math.random() * 700, y: 0, r: 0, b: this.rndBonus() });
                    this.crateTimer = 0;
                }
                
                if (this.score >= this.lastDiff + CFG.diffInc) { this.diff++; this.lastDiff = this.score; }
                
                const spd = this.fx.slow > 0 ? 0.5 : 1;
                this.bullets = this.bullets.filter(b => {
                    b.x += Math.cos(b.a) * CFG.speedBullet * this.dt;
                    b.y += Math.sin(b.a) * CFG.speedBullet * this.dt;
                    return b.x > 0 && b.x < 800 && b.y > 0 && b.y < 600;
                });
                
                this.planes = this.planes.filter(p => {
                    p.x += p.dir * CFG.speedPlane * this.dt * spd;
                    p.t += this.dt;
                    if (p.t > 1000 && Math.random() < 0.01) {
                        const elite = this.diff >= 4 && Math.random() < (this.diff - 3) * 0.05;
                        const tough = !elite && Math.random() < (this.diff - 1) * 0.1;
                        this.paras.push({ x: p.x, y: p.y, hp: elite ? CFG.paraHP[2] : (tough ? CFG.paraHP[1] : CFG.paraHP[0]), 
                                         elite, tough, sw: 0, dir: 1 });
                        p.t = 0;
                    }
                    return p.x > -100 && p.x < 900;
                });
                
                this.paras = this.paras.filter(p => {
                    p.y += CFG.speedPara * this.dt * spd;
                    p.sw += 0.003 * p.dir * this.dt;
                    if (Math.abs(p.sw) > 1) p.dir *= -1;
                    if (p.y >= 560) { this.lives--; if (this.lives <= 0) this.over = true; return false; }
                    return true;
                });
                
                this.crates = this.crates.filter(cr => {
                    cr.y += CFG.speedCrate * this.dt; cr.r += 0.002 * this.dt;
                    return cr.y < 600;
                });
                
                this.bullets.forEach(b => {
                    this.paras = this.paras.filter(p => {
                        const dx = b.x - p.x, dy = b.y - p.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 25) {
                            p.hp -= b.r > CFG.bulletR ? 3 : 1;
                            if (p.hp <= 0) {
                                this.score += (p.elite ? CFG.scoreVals[2] : (p.tough ? CFG.scoreVals[1] : CFG.scoreVals[0])) * 
                                             (this.fx.mult > 0 ? 2 : 1);
                                return false;
                            }
                        }
                        return true;
                    });
                    this.crates = this.crates.filter(cr => {
                        const dx = b.x - cr.x, dy = b.y - cr.y;
                        if (Math.sqrt(dx*dx + dy*dy) < 30) {
                            this.applyBonus(cr.b); return false;
                        }
                        return true;
                    });
                });
            }
            
            fire() {
                const cnt = this.fx.spread > 0 ? 3 : 1, ang = Math.PI/12;
                for (let i = 0; i < cnt; i++) {
                    const a = cnt > 1 ? this.cannonAngle - ang + (ang * i) : this.cannonAngle;
                    this.bullets.push({ x: 400, y: 560, a, r: this.fx.big > 0 ? 6 : CFG.bulletR });
                }
            }
            
            mkPlane() { 
                const dir = Math.random() < 0.5 ? 1 : -1;
                return { x: dir === 1 ? -50 : 850, y: 50 + Math.random() * 100, dir, t: 0 }; 
            }
            
            rndBonus() {
                const bs = [
                    { t: 'points', v: 1000, c: '#ffd700' }, { t: 'life', v: 1, c: '#f44' },
                    { t: 'burst', v: 1, c: '#f80' }, { t: 'spread', v: 1, c: '#4f4' },
                    { t: 'slow', v: 1, c: '#a4f' }, { t: 'nuke', v: 1, c: '#f00' },
                    { t: 'big', v: 1, c: '#44f' }, { t: 'mult', v: 1, c: '#fd0' }
                ];
                return bs[Math.floor(Math.random() * bs.length)];
            }
            
            applyBonus(b) {
                if (b.t === 'points') this.score += b.v;
                else if (b.t === 'life') this.lives += b.v;
                else if (b.t === 'burst') { this.burst = true; this.burstTimer = 3000; this.fireRate = CFG.fireBurst; }
                else if (b.t === 'spread') this.fx.spread = 10000;
                else if (b.t === 'slow') this.fx.slow = 10000;
                else if (b.t === 'big') this.fx.big = 10000;
                else if (b.t === 'mult') this.fx.mult = 15000;
                else if (b.t === 'nuke') { this.paras.forEach(p => this.score += 100); this.paras = []; }
            }
            
            draw() {
                if (!this.started) {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 800, 600);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
                    ctx.fillText('Paratrooper', 400, 250);
                    ctx.font = '20px Arial'; ctx.fillText('Click to Start', 400, 350);
                    return;
                }
                
                ctx.clearRect(0, 0, 800, 600);
                
                
                // Lattia - yksivÃ¤rinen
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 560, 800, 40);
                
                // Tykin piippu
                ctx.save();
                ctx.translate(400, 560);
                ctx.rotate(this.cannonAngle);
                ctx.fillStyle = '#555'; // Harmaa
                ctx.fillRect(0, -8, 45, 16);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, -8, 45, 16);
                ctx.restore();
                
                // Tykin pohja
                ctx.beginPath();
                ctx.arc(400, 560, 20, 0, Math.PI*2);
                ctx.fillStyle = '#444'; // Tumma harmaa
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                this.bullets.forEach(b => {
                    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = '#ff0'; ctx.fill();
                });
                
                this.planes.forEach(p => {
                    ctx.save(); ctx.translate(p.x, p.y); if (p.dir < 0) ctx.scale(-1, 1);
                    ctx.fillStyle = '#aaa'; ctx.fillRect(-30, 0, 60, 10);
                    ctx.fillStyle = '#6af'; ctx.beginPath(); ctx.arc(10, 5, 8, 0, Math.PI*2); ctx.fill();
                    ctx.restore();
                });
                
                this.paras.forEach(p => {
                    const x = p.x + p.sw * 5;
                    ctx.beginPath(); ctx.moveTo(x-20, p.y-20); ctx.quadraticCurveTo(x, p.y-45, x+20, p.y-20);
                    ctx.fillStyle = p.elite ? '#fc0' : (p.tough ? '#44f' : '#f44'); ctx.fill();
                    ctx.beginPath(); ctx.arc(x, p.y, 5, 0, Math.PI*2); ctx.fill();
                    if (p.hp > 1) { ctx.fillStyle = '#fff'; ctx.font = '9px Arial'; ctx.fillText(p.hp, x, p.y-25); }
                });
                
                this.crates.forEach(cr => {
                    ctx.save(); ctx.translate(cr.x, cr.y); ctx.rotate(cr.r);
                    ctx.fillStyle = cr.b.c; ctx.fillRect(-15, -15, 30, 30);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-15, -15, 30, 30);
                    ctx.restore();
                });
                
                ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left';
                ctx.fillText(`Score: ${this.score}`, 10, 30);
                ctx.fillText(`Lives: ${this.lives}`, 10, 60);
                
                if (this.burst) ctx.fillText(`BURST: ${Math.ceil(this.burstTimer/1000)}s`, 10, 90);
                else if (this.burstCool > 0) ctx.fillText(`Burst: ${Math.ceil(this.burstCool/1000)}s`, 10, 90);
                
                if (this.over) {
                    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 800, 600);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 400, 280);
                    ctx.font = '20px Arial'; ctx.fillText(`Score: ${this.score}`, 400, 320);
                    ctx.fillText('Click to Restart', 400, 360);
                }
            }
        }
        
        const game = new Game();
        function loop(t) { game.update(t); game.draw(); requestAnimationFrame(loop); }
        requestAnimationFrame(loop);
    </script>
</body>
</html>