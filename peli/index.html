<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Paratrooper</title>

<style>
body {
display: flex;
justify-content: center;
align-items: center;
height: 100vh;
margin: 0;
background: #000;
}

canvas {
border: 2px solid #333;
background-image: url('https://i.pinimg.com/736x/4a/e6/48/4ae648aaacc1bccfef1f649245adc6a2.jpg');
background-size: cover;
background-position: center;
}

#scoreboard {
position: fixed;
right: 20px;
top: 20px;
width: 200px;
background: rgba(0, 0, 0, 0.7);
color: #fff;
padding: 10px;
font-family: Arial;
border: 2px solid #555;
}

#scoreboard h3 {
margin: 0 0 10px 0;
text-align: center;
}

#scoreboard li {
margin: 4px 0;
}

#nameInput {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0, 0, 0, 0.9);
padding: 30px;
border: 3px solid #555;
border-radius: 10px;
text-align: center;
display: none;
}

#nameInput h2 {
color: #fff;
margin: 0 0 20px 0;
font-family: Arial;
}

#nameInput input {
padding: 10px;
font-size: 18px;
width: 250px;
border: 2px solid #555;
border-radius: 5px;
background: #222;
color: #fff;
font-family: Arial;
}

#nameInput button {
margin-top: 15px;
padding: 10px 30px;
font-size: 18px;
background: #4a4;
color: #fff;
border: none;
border-radius: 5px;
cursor: pointer;
font-family: Arial;
font-weight: bold;
}

#nameInput button:hover {
background: #5b5;
}

#nameInput input:focus {
outline: none;
border-color: #4a4;
}
</style>
</head>
<body>

<div id="nameInput">
<h2>Enter Your Name</h2>
<input type="text" id="playerNameField" placeholder="Player Name" maxlength="20" autocomplete="off">
<br>
<button id="startButton">Start Game</button>
</div>

<div id="scoreboard">
<h3>Score board</h3>
<ol id="list"></ol>
</div>

<canvas id="c" width="800" height="600"></canvas>
<script>
const c = document.getElementById('c'), ctx = c.getContext('2d');
const CFG = {
    lives: 5, diffInc: 2500, fireNormal: 167, fireBurst: 17, burstDur: 3000, burstCool: 8000,
    spawnPlane: 2000, spawnCrate: 4000, crateChance: 0.05, speedBullet: 0.7, speedPlane: 0.24,
    speedPara: 0.06, speedCrate: 0.25, bulletR: 3, paraHP: [1, 3, 6], scoreVals: [100, 300, 600]
};

const CUSTOM_SOUNDS = {
    shoot: "채채net/laskuvarjo.mp3",
    hit: "채채net/laskuvarjo.mp3",
    bonus: "bonus.wav",
    nuke: "nuke.wav",
    gameover: "gameover.mp3"
};

class Game {
    constructor() {
        this.playerName = '';
        this.nameEntered = false;
        this.loadScoreboard();
        this.reset();
        
        // Show name input on load
        document.getElementById('nameInput').style.display = 'block';
        
        // Handle name submission
        const startButton = document.getElementById('startButton');
        const nameField = document.getElementById('playerNameField');
        
        const submitName = () => {
            const name = nameField.value.trim();
            if (name) {
                this.playerName = name;
                this.nameEntered = true;
                document.getElementById('nameInput').style.display = 'none';
            } else {
                nameField.placeholder = 'Please enter a name!';
                nameField.style.borderColor = '#f44';
            }
        };
        
        startButton.addEventListener('click', submitName);
        nameField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitName();
        });
        
        // hiiren liike --> tykin kulma
        c.addEventListener('mousemove', e => {
            const rect = c.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            this.cannonAngle = Math.max(-Math.PI, Math.min(0, Math.atan2(my - 560, mx - 400)));
        });
        
        // hiiren painike ammutaan
        c.addEventListener('mousedown', () => this.mouseDown = true);
        c.addEventListener('mouseup', () => this.mouseDown = false);

        // click aloittaa pelin ja vapauttaa audio-contextin
        c.addEventListener('click', async () => {
            if (!this.nameEntered) {
                return; // Don't start until name is entered
            }
            if (!this.started) {
                this.started = true;
                if (this.audioCtx && this.audioCtx.state === 'suspended') {
                    try { await this.audioCtx.resume(); } catch (e) { /* ignore */ }
                }
                this.startBackground();
            } else if (this.over) {
                this.reset();
            }
        });

        // burst avain
        document.addEventListener('keydown', e => {
            if (e.code === 'Space' && !this.burst && this.burstCool <= 0) {
                this.burst = true; this.burstTimer = CFG.burstDur; this.fireRate = CFG.fireBurst;
            }
        });
    }

    reset() {
        this.score = 0; this.lives = CFG.lives; this.over = false; this.started = false;
        this.bullets = []; this.planes = []; this.paras = []; this.crates = [];
        this.cannonAngle = -Math.PI/4; this.mouseDown = false; this.fireRate = CFG.fireNormal;
        this.fireTimer = 0; this.planeTimer = 0; this.crateTimer = 0;
        this.burst = false; this.burstTimer = 0; this.burstCool = 0;
        this.diff = 1; this.lastDiff = 0; this.lastTime = 0; this.dt = 0;
        this.fx = { slow: 0, mult: 0, spread: 0, big: 0 };

        try {
            const AudioCtx = window.AudioContext || window.webkitAudioContext;
            this.audioCtx = new AudioCtx();
        } catch (e) {
            this.audioCtx = null;
        }
        this.audioGain = 0.8;
        this.setupAudioNodes();

        this.buffers = {};
        this.loadCustomSounds();
        this.updateScoreboardDisplay();
    }

    setupAudioNodes() {
        if (!this.audioCtx) return;
        const ctx = this.audioCtx;
        this.master = ctx.createGain();
        this.master.gain.value = this.audioGain;
        this.master.connect(ctx.destination);

        this.bgGain = ctx.createGain();
        this.bgGain.gain.value = 0;
        this.bgGain.connect(this.master);

        this.bgOsc = ctx.createOscillator();
        this.bgOsc.type = 'sine';
        this.bgOsc.frequency.value = 80;
        this.bgOsc.connect(this.bgGain);
        this.bgOsc.start();

        this.lfo = ctx.createOscillator();
        this.lfo.frequency.value = 0.25;
        this.lfoGain = ctx.createGain();
        this.lfoGain.gain.value = 20;
        this.lfo.connect(this.lfoGain);
        this.lfoGain.connect(this.bgOsc.frequency);
        this.lfo.start();
    }

    async loadCustomSounds() {
        if (!this.audioCtx) return;
        const ctx = this.audioCtx;
        const entries = Object.entries(CUSTOM_SOUNDS);
        for (const [name, url] of entries) {
            if (!url) continue;
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const arr = await res.arrayBuffer();
                const decoded = await ctx.decodeAudioData(arr.slice(0));
                this.buffers[name] = decoded;
            } catch (err) {
                console.warn('Custom sound load failed for', name, url, err);
                delete this.buffers[name];
            }
        }
    }

    startBackground() {
        if (!this.audioCtx) return;
        const now = this.audioCtx.currentTime;
        this.bgGain.gain.cancelScheduledValues(now);
        this.bgGain.gain.setValueAtTime(0, now);
        this.bgGain.gain.linearRampToValueAtTime(0.03, now + 1.0);
    }

    loadScoreboard() {
        const stored = localStorage.getItem('paratrooperScores');
        this.scoreboard = stored ? JSON.parse(stored) : [];
    }

    saveScoreboard() {
        localStorage.setItem('paratrooperScores', JSON.stringify(this.scoreboard));
    }

    addScore(name, score) {
        this.scoreboard.push({ name, score });
        this.scoreboard.sort((a, b) => b.score - a.score);
        this.scoreboard = this.scoreboard.slice(0, 5);
        this.saveScoreboard();
        this.updateScoreboardDisplay();
    }

    updateScoreboardDisplay() {
        const list = document.getElementById('list');
        list.innerHTML = '';
        this.scoreboard.forEach((entry, i) => {
            const li = document.createElement('li');
            li.textContent = `${entry.name}: ${entry.score}`;
            list.appendChild(li);
        });
    }

    playTone({freq=440, type='sine', dur=0.12, attack=0.002, release=0.06, gain=0.5, detune=0}) {
        if (!this.audioCtx) return;
        const ctx = this.audioCtx;
        const o = ctx.createOscillator();
        o.type = type;
        o.frequency.value = freq;
        o.detune.value = detune;
        const g = ctx.createGain();
        g.gain.value = 0;
        o.connect(g);
        g.connect(this.master);

        const t0 = ctx.currentTime;
        g.gain.cancelScheduledValues(t0);
        g.gain.setValueAtTime(0, t0);
        g.gain.linearRampToValueAtTime(gain, t0 + attack);
        g.gain.linearRampToValueAtTime(0.0001, t0 + dur - release);
        o.start(t0);
        o.stop(t0 + dur + 0.02);
    }

    playBuffer(name) {
        if (!this.audioCtx || !this.buffers[name]) return;
        try {
            const src = this.audioCtx.createBufferSource();
            src.buffer = this.buffers[name];
            src.connect(this.master);
            src.start();
        } catch (e) {
            console.warn('playBuffer failed', name, e);
        }
    }

    playSound(name) {
        if (this.buffers && this.buffers[name]) {
            this.playBuffer(name);
            return;
        }

        if (!this.audioCtx) return;
        if (name === 'shoot') {
            this.playTone({freq: 900 + Math.random()*120, type: 'triangle', dur: 0.08, gain: 0.25});
        } else if (name === 'hit') {
            this.playTone({freq: 200 + Math.random()*80, type: 'sawtooth', dur: 0.12, gain: 0.22});
            this.playTone({freq: 1200, type: 'square', dur: 0.02, gain: 0.08});
        } else if (name === 'bonus') {
            for (let i=0;i<3;i++){
                const f = 600 + i*120;
                setTimeout(()=> this.playTone({freq: f, type: 'sine', dur: 0.08, gain: 0.18}), i*60);
            }
        } else if (name === 'nuke') {
            const ctx = this.audioCtx;
            const o = ctx.createOscillator();
            o.type = 'sawtooth';
            o.frequency.value = 60;
            const g = ctx.createGain(); g.gain.value = 0;
            o.connect(g); g.connect(this.master);
            const t0 = ctx.currentTime;
            g.gain.linearRampToValueAtTime(0.6, t0 + 0.01);
            o.frequency.linearRampToValueAtTime(1200, t0 + 0.6);
            g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.9);
            o.start(t0); o.stop(t0 + 1.0);
        } else if (name === 'gameOver') {
            this.playTone({freq: 240, type:'sine', dur:0.35, gain:0.2});
            setTimeout(()=> this.playTone({freq:160, type:'sine', dur:0.45, gain:0.18}), 220);
        }
    }

    update(t) {
        if (!this.lastTime) this.lastTime = t;
        this.dt = t - this.lastTime; this.lastTime = t;
        if (!this.started || this.over) return;

        Object.keys(this.fx).forEach(k => { if (this.fx[k] > 0) this.fx[k] -= this.dt; });

        if (this.burst) {
            this.burstTimer -= this.dt;
            if (this.burstTimer <= 0) { this.burst = false; this.fireRate = CFG.fireNormal; this.burstCool = CFG.burstCool; }
        }
        if (this.burstCool > 0) this.burstCool -= this.dt;

        if (this.mouseDown) {
            this.fireTimer += this.dt;
            if (this.fireTimer >= this.fireRate) {
                this.fire(); this.fireTimer = 0;
            }
        }

        this.planeTimer += this.dt;
        if (this.planeTimer > Math.max(400, CFG.spawnPlane - this.diff*50)) { this.planes.push(this.mkPlane()); this.planeTimer = 0; }

        this.crateTimer += this.dt;
        if (this.crateTimer > CFG.spawnCrate && Math.random() < CFG.crateChance) {
            this.crates.push({ x: 50 + Math.random() * 700, y: 0, r: 0, b: this.rndBonus() });
            this.crateTimer = 0;
        }

        if (this.score >= this.lastDiff + CFG.diffInc) { this.diff++; this.lastDiff = this.score; }

        const spd = this.fx.slow > 0 ? 0.5 : 1;
        this.bullets = this.bullets.filter(b => {
            b.x += Math.cos(b.a) * CFG.speedBullet * this.dt;
            b.y += Math.sin(b.a) * CFG.speedBullet * this.dt;
            return b.x > 0 && b.x < 800 && b.y > 0 && b.y < 600;
        });

        this.planes = this.planes.filter(p => {
            p.x += p.dir * CFG.speedPlane * this.dt * spd;
            p.t += this.dt;
            if (p.t > 1000 && Math.random() < 0.01) {
                const elite = this.diff >= 4 && Math.random() < (this.diff - 3) * 0.05;
                const tough = !elite && Math.random() < (this.diff - 1) * 0.1;
                this.paras.push({ x: p.x, y: p.y, hp: elite ? CFG.paraHP[2] : (tough ? CFG.paraHP[1] : CFG.paraHP[0]), 
                                 elite, tough, sw: 0, dir: 1 });
                p.t = 0;
            }
            return p.x > -100 && p.x < 900;
        });

        this.paras = this.paras.filter(p => {
            p.y += CFG.speedPara * this.dt * spd;
            p.sw += 0.003 * p.dir * this.dt;
            if (Math.abs(p.sw) > 1) p.dir *= -1;
            
            // Keep paratroopers within screen bounds
            const swayOffset = p.sw * 5;
            if (p.x + swayOffset < 10) {
                p.x = 10 - swayOffset;
            } else if (p.x + swayOffset > 790) {
                p.x = 790 - swayOffset;
            }
            
            if (p.y >= 560) { 
                this.lives--; 
                if (this.lives <= 0) { 
                    this.over = true; 
                    this.playSound('gameOver');
                    this.addScore(this.playerName, this.score);
                } 
                return false; 
            }
            return true;
        });

        this.crates = this.crates.filter(cr => {
            cr.y += CFG.speedCrate * this.dt; cr.r += 0.002 * this.dt;
            return cr.y < 600;
        });

        this.bullets.forEach(b => {
            this.paras = this.paras.filter(p => {
                const dx = b.x - p.x, dy = b.y - p.y;
                if (Math.sqrt(dx*dx + dy*dy) < 25) {
                    p.hp -= b.r > CFG.bulletR ? 3 : 1;
                    this.playSound('hit');
                    if (p.hp <= 0) {
                        this.score += (p.elite ? CFG.scoreVals[2] : (p.tough ? CFG.scoreVals[1] : CFG.scoreVals[0])) * 
                                     (this.fx.mult > 0 ? 2 : 1);
                        return false;
                    }
                }
                return true;
            });
            this.crates = this.crates.filter(cr => {
                const dx = b.x - cr.x, dy = b.y - cr.y;
                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                    this.applyBonus(cr.b); this.playSound('bonus'); return false;
                }
                return true;
            });
        });
    }

    fire() {
        const cnt = this.fx.spread > 0 ? 3 : 1, ang = Math.PI/12;
        for (let i = 0; i < cnt; i++) {
            const a = cnt > 1 ? this.cannonAngle - ang + (ang * i) : this.cannonAngle;
            this.bullets.push({ x: 400, y: 560, a, r: this.fx.big > 0 ? 6 : CFG.bulletR });
            this.playSound('shoot');
        }
    }

    mkPlane() { 
        const dir = Math.random() < 0.5 ? 1 : -1;
        return { x: dir === 1 ? -50 : 850, y: 50 + Math.random() * 100, dir, t: 0 }; 
    }

    rndBonus() {
        const bs = [
            { t: 'points', v: 1000, c: '#ffd700' }, { t: 'life', v: 1, c: '#f44' },
            { t: 'burst', v: 1, c: '#f80' }, { t: 'spread', v: 1, c: '#4f4' },
            { t: 'slow', v: 1, c: '#a4f' }, { t: 'nuke', v: 1, c: '#f00' },
            { t: 'big', v: 1, c: '#44f' }, { t: 'mult', v: 1, c: '#fd0' }
        ];
        return bs[Math.floor(Math.random() * bs.length)];
    }

    applyBonus(b) {
        if (!b) return;
        if (b.t === 'points') this.score += b.v;
        else if (b.t === 'life') this.lives += b.v;
        else if (b.t === 'burst') { this.burst = true; this.burstTimer = CFG.burstDur; this.fireRate = CFG.fireBurst; }
        else if (b.t === 'spread') this.fx.spread = 10000;
        else if (b.t === 'slow') this.fx.slow = 10000;
        else if (b.t === 'big') this.fx.big = 10000;
        else if (b.t === 'mult') this.fx.mult = 15000;
        else if (b.t === 'nuke') { 
            this.paras.forEach(p => this.score += 100);
            this.paras = [];
            this.playSound('nuke');
        }
    }

    draw() {
        if (!this.nameEntered) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 800, 600);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Paratrooper', 400, 250);
            return;
        }
        
        if (!this.started) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 800, 600);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Paratrooper', 400, 220);
            ctx.font = '24px Arial'; 
            ctx.fillText(`Welcome, ${this.playerName}!`, 400, 280);
            ctx.font = '20px Arial'; 
            ctx.fillText('Click to Start', 400, 350);
            return;
        }

        ctx.clearRect(0, 0, 800, 600);

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 560, 800, 40);

        ctx.save();
        ctx.translate(400, 560);
        ctx.rotate(this.cannonAngle);
        ctx.fillStyle = '#555';
        ctx.fillRect(0, -8, 45, 16);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, -8, 45, 16);
        ctx.restore();

        ctx.beginPath();
        ctx.arc(400, 560, 20, 0, Math.PI*2);
        ctx.fillStyle = '#444';
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.stroke();

        this.bullets.forEach(b => {
            ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = '#ff0'; ctx.fill();
        });

        this.planes.forEach(p => {
            ctx.save(); ctx.translate(p.x, p.y); if (p.dir < 0) ctx.scale(-1, 1);
            ctx.fillStyle = '#aaa'; ctx.fillRect(-30, 0, 60, 10);
            ctx.fillStyle = '#6af'; ctx.beginPath(); ctx.arc(10, 5, 8, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        });

        this.paras.forEach(p => {
            const x = p.x + p.sw * 5;
            ctx.beginPath(); ctx.moveTo(x-20, p.y-20); ctx.quadraticCurveTo(x, p.y-45, x+20, p.y-20);
            ctx.fillStyle = p.elite ? '#fc0' : (p.tough ? '#44f' : '#f44'); ctx.fill();
            ctx.beginPath(); ctx.arc(x, p.y, 5, 0, Math.PI*2); ctx.fill();
            if (p.hp > 1) { ctx.fillStyle = '#fff'; ctx.font = '9px Arial'; ctx.fillText(p.hp, x, p.y-25); }
        });

        this.crates.forEach(cr => {
            ctx.save(); ctx.translate(cr.x, cr.y); ctx.rotate(cr.r);
            ctx.fillStyle = cr.b.c; ctx.fillRect(-15, -15, 30, 30);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-15, -15, 30, 30);
            ctx.restore();
        });

        ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left';
        ctx.fillText(`${this.playerName}: ${this.score}`, 10, 30);
        ctx.fillText(`Lives: ${this.lives}`, 10, 60);

        if (this.burst) ctx.fillText(`BURST: ${Math.ceil(this.burstTimer/1000)}s`, 10, 90);
        else if (this.burstCool > 0) ctx.fillText(`Burst: ${Math.ceil(this.burstCool/1000)}s`, 10, 90);

        if (this.over) {
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0, 0, 800, 600);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', 400, 250);
            ctx.font = '24px Arial'; 
            ctx.fillText(`${this.playerName}: ${this.score}`, 400, 300);
            ctx.font = '20px Arial';
            ctx.fillText('Click to Restart', 400, 360);
        }
    }
}

const game = new Game();
function loop(t) { game.update(t); game.draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>
</body>
</html>